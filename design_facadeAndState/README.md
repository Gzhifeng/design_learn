### 外观、状态模式笔记
#### 什么是外观模式
外观模式（Facade）,他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。
#### 外观模式角色
1. 门面角色：外观模式的核心。它被客户角色调用，内部根据客户角色的需求预定了几种功能的组合。
2. 子系统角色：实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。
3. 客户角色:通过调用Facede来完成要实现的功能。
#### 优点
- 松散耦合
  + 使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；
- 简单易用
  + 客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。
- 更好的划分访问层次
  + 有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。
---

#### 什么是状态模式
状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。
#### 状态模式应用场景
1. 一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。
2. 操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常,有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。
#### 状态模式与策略模式区别
1. 状态模式重点在各状态之间的切换从而做不同的事情，而策略模式更侧重于根据具体情况选择策略，并不涉及切换。
2. 状态模式不同状态下做的事情不同，而策略模式做的都是同一件事。例如聚合支付平台，有支付宝、微信支付、银联支付，虽然策略不同，但最终做的事情都是支付，也就是说他们之间是可替换的。反观状态模式，各个状态的同一方法做的是不同的事，不能互相替换。
3. 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而通过从Context中分离出策略或算法，我们可以重用它们。在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。
