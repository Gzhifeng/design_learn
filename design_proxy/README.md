### 代理模式笔记
#### 什么是代理模式
为其它对象提供一种代理以控制对象的访问。   
#### 为什么使用代理模式
- 中介隔离：在某些情况下，一个客户类不能或不能直接访问一个委托对象，而代理类可以在客户类和委托对象之间起到中介的作用，其特征是，代理类和委托类实现相同的接口。
- 符合开闭原则：代理类除了是客户类和委托类的中介之外，我们还可以通过增加代理类的功能来拓展委托类。这样在增加功能的时候我们可以通过修改代理类来实现功能，而不用修改委托类，符合开闭原则。代理类主要负责为委托类预处理消息、过滤消息、传递消息以及事后对返回结果的处理等。代理类本身不提供服务，而是调用委托类的相关方法来提供特定的服务，真正的业务功能还是有委托类来实现，但是可以在业务功能执行前后加入一些公共的服务。例如：给项目加入缓存、日志等这些功能，我们可以通过使用代理类来完成，没有必要打开委托类。

#### 代理模式元素
代理模式主要包含三个元素：抽象主题角色、委托类角色（被代理的类）、代理类角色。
- 抽象主题角色：可以是接口，也可以是抽象类。
- 委托类角色：真实主题角色，业务逻辑具体执行者。
- 代理类角色：内部含有对真实对象的引用，负责对真实主题角色的调用，并在真实主题角色处理前后做预处理和后处理。


#### 代理模式应用场景
SpringAop、日志收集、权限控制、过滤器、RPC远程调用

#### 代理模式创建方式
静态代理和动态代理
- 静态代理：是由程序员创建或工具类生成代理类的源码，在编译代理类。所谓的静态也就是程序在运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就已经确定了（由程序员手动创建的代理类就是静态代理）。 
  - 实现方式：
  1. 基于接口  
  2. 基于实现
- 动态代理：动态代理在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。动态代理类是程序在运行期间由JVM通过反射等机制动态生成的。
  1. **jdk动态代理（创建步骤）**
      1. 创建被代理的接口或类  
      2. 实现InvocationHandler接口，对目标接口中声明的所有方法进行统一的处理
      3. 调用proxy的静态方法，创建代理类并生成相应的代理对象
  2. **cglib动态代理**    
    cglib是一个强大的，高性能，高质量的代码生成类库，它可以在运行期间扩充java类和java接口。其底层实现是通过ASM字节码处理框架来转换字节码并生成新的类。大部分功能实际上是ASM所提供的，cglib只是封装了ASM并简化了操作，实现运行期间生成新的class
      1. **cglib原理**   
      运行时动态的生成一个被代理类的子类（通过ASM字节码处理框架实现），子类重写了被代理类中所有的非final方法。在子类中采用方法拦截技术拦截所有父类方法的调用，顺势植入横切逻辑
      2. **cglib优缺点**   
      **优点：** jdk动态代理要求被代理的类必须实现接口，当被代理的类没有实现接口时cglib是一个很好的选择。另一个优点是cglib动态代理比使用jdk动态代理效率高    
      **缺点：** 对应被代理的类中的final方法无法重写，因为子类无法重写final方法   
      3. **cglib代理实现：**   
      实现MethodInterceptor接口中的intercept方法后，所有生成的代理方法都调用这个方法。   
      obj目标类实例   
      1.method目标方法实例（通过反射获取的目标方法实例）   
      2.args目标方法参数   
      3.proxy代理类的实例   
      改方法的返回值就是目标方法的返回值
  3. **静态代理与动态代理的区别**   
    静态代理需要自己生成代理类，动态代理不需要自己生成代理类   
  4. **jdk动态代理与cglib动态代理的实现**   
     1. **jdk动态代理的底层实现**   
        jdk动态代理使用java的反射技术动态的生成代理类，只能代理实现接口的类。
     2. **cglib动态代理的底层实现**   
     运行时动态的生成一个被代理类的子类（通过ASM字节码处理框架实现），子类重写了被代理类中所有非final的方法，在子类中采用方法拦截的技术拦截所有父类
     的方法调用，不需要被代理类对象实现接口，从而CGLIB动态代理效率比Jdk动态代理反射技术效率要高